<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Yanfei Huang</title>
    <link>https://hyflying.github.io/</link>
      <atom:link href="https://hyflying.github.io/index.xml" rel="self" type="application/rss+xml" />
    <description>Yanfei Huang</description>
    <generator>Hugo Blox Builder (https://hugoblox.com)</generator><language>en-us</language><lastBuildDate>Mon, 24 Oct 2022 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://hyflying.github.io/media/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_3.png</url>
      <title>Yanfei Huang</title>
      <link>https://hyflying.github.io/</link>
    </image>
    
    <item>
      <title>Example Talk</title>
      <link>https://hyflying.github.io/talk/example-talk/</link>
      <pubDate>Sat, 01 Jun 2030 13:00:00 +0000</pubDate>
      <guid>https://hyflying.github.io/talk/example-talk/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Click on the &lt;strong&gt;Slides&lt;/strong&gt; button above to view the built-in slides feature.
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Slides can be added in a few ways:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Create&lt;/strong&gt; slides using Hugo Blox Builder&amp;rsquo;s &lt;a href=&#34;https://docs.hugoblox.com/reference/content-types/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;em&gt;Slides&lt;/em&gt;&lt;/a&gt; feature and link using &lt;code&gt;slides&lt;/code&gt; parameter in the front matter of the talk file&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Upload&lt;/strong&gt; an existing slide deck to &lt;code&gt;static/&lt;/code&gt; and link using &lt;code&gt;url_slides&lt;/code&gt; parameter in the front matter of the talk file&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Embed&lt;/strong&gt; your slides (e.g. Google Slides) or presentation video on this page using &lt;a href=&#34;https://docs.hugoblox.com/reference/markdown/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;shortcodes&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Further event details, including &lt;a href=&#34;https://docs.hugoblox.com/reference/markdown/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;page elements&lt;/a&gt; such as image galleries, can be added to the body of this page.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>E-commerce flash sales FAQ</title>
      <link>https://hyflying.github.io/post/e-commerce-flash-sales/</link>
      <pubDate>Wed, 01 May 2024 00:00:00 +0000</pubDate>
      <guid>https://hyflying.github.io/post/e-commerce-flash-sales/</guid>
      <description>&lt;p&gt;GitHub link: &lt;a href=&#34;https://github.com/hyflying/FlashSaleProject&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/hyflying/FlashSaleProject&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;faq&#34;&gt;FAQ&lt;/h1&gt;
&lt;h2 id=&#34;怎么防止超卖的&#34;&gt;怎么防止超卖的&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;一开始跟着做项目的时候 防止超卖是用的Redis配合Lua脚本预减库存来实现的 后来通过学习和思考 感觉Lua脚本不是必要的 因为Redis提供的incr和decr命令本身就是原子性的 然后又发现靠Redis预减库存来实现也不是最好的方案 因为防止超卖就是防止数据库库存小于零 那就在更新库存的时候加一个判断 库存大于零时才可以成功减库存 就可以实现防止超卖了 这种方式就要求我们系统上游做好限流并消息队列异步下单 使得到数据库的并发量在数据库能接受的范畴内&lt;/li&gt;
&lt;li&gt;当然如果数据库压力还是太大 这时候可以采用Redis来保护数据库 在异步下单前用Redis预减库存（当Redis库存已经为0的时候 就没有必要再去尝试更新数据库了） 这样也可以减少数据库压力 但Redis主要是起到辅助作用 防止超卖的实现最终还是靠数据库
-还有其他解决方案 比如服务单机部署的时候可以用synchroinzed和reentrantlock -服务多机部署的时候可以用分布式锁 但我个人感觉是把事情复杂化了&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;怎么做的限流&#34;&gt;怎么做的限流&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;项目里主要是&lt;/li&gt;
&lt;li&gt;接口限流 统计用户短时间内发送请求的次数 如果超过阈值就拒绝请求（将访问的接口和用户id作为键，访问次数作为值存入到redis中）&lt;/li&gt;
&lt;li&gt;验证码限流 将瞬间的请求分散到一个区间内 降低服务器压力&lt;/li&gt;
&lt;li&gt;更好的做法&lt;/li&gt;
&lt;li&gt;采用令牌桶算法控制请求到达服务器的速度&lt;/li&gt;
&lt;li&gt;在消息队列的生产端 可以通过Redis来保证消息的幂等性 最好做到每个用户只发送一个有效请求 多余的请求拦截&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;限流-令牌桶算法&#34;&gt;限流-令牌桶算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;令牌桶算法：固定大小的令牌桶以恒定的速率生成令牌，当令牌消耗速率小于生成的速率时，令牌就会不断增加，直到把桶填满，拿到令牌的用户才能执行后续的操作，以此来实现限流。&lt;/li&gt;
&lt;li&gt;漏桶算法：请求先放到漏桶里，然后以一定的速度放出，当请求流入速度过大时漏桶会直接溢出，溢出的请求就丢弃掉&lt;/li&gt;
&lt;li&gt;二者的区别是漏桶算法能强行改变请求流出漏桶的速度，令牌桶在这个基础上还能允许某种程度的突发传输（只要令牌桶中还有令牌，就可以一直来取，直到桶里没有令牌了）&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;令牌桶&lt;/strong&gt;: 维护一个令牌桶，该桶以固定的速率添加令牌。桶有一个容量上限，当桶满时，新产生的令牌会被丢弃。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;请求处理&lt;/strong&gt;: 当一个请求到达服务器时，它需要从令牌桶中取出一个令牌才能被处理。如果桶中有足够的令牌，请求被允许通过并且相应数量的令牌被移除；如果桶中没有足够的令牌，请求要么被拒绝，要么被排队等待直到有足够的令牌。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;速率控制&lt;/strong&gt;: 通过调整令牌的添加速率和桶的容量，可以控制请求到达服务器的速度。添加令牌的速率决定了允许的最大请求速率，而桶的容量决定了在短时间内允许的突发请求量。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;项目中的技术难点-怎么解决的防止超卖-限流-缓存数据库一致性&#34;&gt;项目中的技术难点 怎么解决的（防止超卖 限流 缓存数据库一致性）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;最主要的就是如何解决超卖的问题一开始跟着做项目的时候 就是用的Redis配合Lua脚本预减库存来实现的 后来通过学习别的资料发现还有其他解决方案 比如服务单机部署的时候可以用synchroinzed和reentrantlock 服务多级部署的时候可以用分布式锁 但我感觉这些都把问题复杂化了，最好的方式还是通过数据库来实现 因为防止超卖就是防止数据库库存小于零 那就在更新库存的时候加一个判断 库存大于零时才可以成功减库存 这种方式就要求我们系统上游做好限流 比如令牌桶 拿到令牌的请求通过消息队列异步下单 如果数据库压力还是太大 可以在异步下单前用Redis预减库存（通过Redis提供的incr decr原子操作） 当Redis库存已经为0的时候 就没有必要再去尝试更新数据库了 这样也可以减少数据库压力 Redis主要是起到辅助作用&lt;/li&gt;
&lt;li&gt;限流&lt;/li&gt;
&lt;li&gt;其次就是通过Redis来实现消息队列生产端消息幂等性，缓解数据库和缓存不一致的问题，在秒杀场景中缓存和数据库数据不一致的影响不是很大 因为最严重的情况就是数据库中还有库存 而缓存中库存为0了 导致用户无法购买 我感觉出现这种情况最大的可能就是 一个用户发送了多个秒杀请求 预减了多次Redis库存 但是最后只能成功扣减数据库库存一次 可以通过这种方式解决 在用户第一次秒杀请求预减库存之后 将用户ID-商品ID存入一个set中（预减库存和存Set两步放到Lua脚本里保证原子性），在Redis预减库存之前先判断该用户是否已经发送了对该商品的秒杀请求 如果有了就返回请勿重复秒杀 这样一来不一致性能缓解很多&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;怎么解决的数据库和缓存一致性问题&#34;&gt;怎么解决的数据库和缓存一致性问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在秒杀场景中缓存和数据库数据不一致的影响不是很大 因为最严重的情况就是数据库中还有库存（redis预减库存成功，但是mysql减库存失败） 而缓存中库存为0了 导致用户无法购买 我感觉出现这种情况最大的可能就是 一个用户发送了多个秒杀请求 预减了多次Redis库存 但是最后只能成功扣减数据库库存一次 可以通过这种方式解决 在用户第一次秒杀请求预减库存之后 将用户ID-商品ID存入一个set中（预减库存和存Set两步放到Lua脚本里保证原子性），在Redis预减库存之前先判断该用户是否已经发送了对该商品的秒杀请求 如果有了就返回请勿重复秒杀 这样一来不一致性能缓解很多&lt;/li&gt;
&lt;li&gt;此外如果秒杀时间很短 那没有必要保持数据库和缓存的一致性 只要保证不超卖 少卖一些产品也没关系 如果秒杀时间比较长或者存在补货行为 可以定期或者在系统并发量小的时候把数据库的库存同步到缓存中 也不需要保证数据强一致&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;如何设计一个高并发秒杀系统&#34;&gt;如何设计一个高并发秒杀系统&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;主要就是针对三个方面 高性能、一致性、高可用&lt;/li&gt;
&lt;li&gt;高性能是指能够支持高并发访问&lt;/li&gt;
&lt;li&gt;一致性是指在大量并发减库存情况下保证库存的正确性 不能多卖、少卖&lt;/li&gt;
&lt;li&gt;高可用是指在复杂的工况下能保证秒杀活动的顺利进行&lt;/li&gt;
&lt;li&gt;核心思想就是尽量将请求拦截在系统的上游 尽量采用缓存来保护数据库 同步操作异步化 尽早失败、保护业务系统&lt;/li&gt;
&lt;li&gt;比如10万个用户来抢100个资源，其中有99.9%的用户请求都是无效的，那就没有必要让这么多请求到达缓存甚至数据库，徒增系统压力，此时可以通过Redis令牌限流，只允许5000个请求进入业务系统，但是5000个请求并发去操作数据库，数据库可能也会扛不住，所以需要做异步处理，把5000个请求放到消息队列慢慢处理，有效地把并发同步请求变成了串行异步。&lt;/li&gt;
&lt;li&gt;优化的方法有限流、削峰、异步、利用缓存、禁止重复请求和重复下单、内存标记、隐藏秒杀接口、&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;为什么用redis-redis单线程和高并发不是矛盾吗&#34;&gt;为什么用Redis Redis单线程和高并发不是矛盾吗&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;这个要看场景 比如秒杀商品只有10个库存 秒杀时候有十万个请求过来 在系统上游进行拦截 只放50或者100个请求进去 其他直接拦截 那么就不需要Redis了 数据库完全可以承受这个程度的并发量 但如果是1000的库存 那至少需要放5000的请求进来 如果这么多请求打到数据库上 会造成比较严重的读写冲突 用户体验不会好 而且如果并发量再大一些的话 数据库可能直接崩掉了 所以这时候就要用缓存和异步处理来保护数据库&lt;/li&gt;
&lt;li&gt;Redis确实是单线程的 但是也比并发条件下的数据库读写快太多了（它是面向短快请求的缓存服务(不处理大数据量的请求和复杂事务)、基于内存、数据结构简单）相比较于数据库崩掉的风险 Redis单线程这里损耗的性能不是很关键 还是得先保证秒杀活动能正常进行&lt;/li&gt;
&lt;li&gt;从另一个角度来说 既然超过百分之99的请求都是无效请求 那就应该让它们越早失败越好 如果不用Redis做缓存 得到查到数据库库存的时候才让它失败 压力就又来到数据库这边了&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;高并发场景用乐观锁还是悲观锁&#34;&gt;高并发场景用乐观锁还是悲观锁&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;这个还是要看具体的场景&lt;/li&gt;
&lt;li&gt;如果系统上游没有做好限流 数据库面临大量的并发读写 这时候用悲观锁 如果用乐观锁会导致大量的请求返回失败 用户体验和系统性能都不好&lt;/li&gt;
&lt;li&gt;如果系统的上游做了限流 到数据库的请求不是瞬时大量的话 可以用版本号机制的乐观锁 因为请求不多 就算失败了也很快能重试成功 可以提高系统性能&lt;/li&gt;
&lt;li&gt;加锁能解决很多问题 但是一旦加锁就会涉及到锁的竞争 性能就会下降&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;慢sql优化-分库分表&#34;&gt;慢SQL优化 分库分表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;先通过慢查询日志来定位慢SQL 它会记录执行时间超过指定时间的SQL&lt;/li&gt;
&lt;li&gt;如果查询语句用了* 改成具体字段 如果用了嵌套 改成多表联查&lt;/li&gt;
&lt;li&gt;看条件部分有没有用索引 没有索引添加索引 用了索引看是否失效&lt;/li&gt;
&lt;li&gt;数据库优化方面 读写分离、主从复制、负载均衡 增加innodb_buffer_pool_size的大小 这样能提高写的速度（能不去硬盘写就不去硬盘写）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;秒杀中如何解决重复下单问题&#34;&gt;秒杀中如何解决重复下单问题？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;缓存方面：用户生成了秒杀订单后，会将用户信息、商品信息作为key，将订单信息作为val，存放到redis中，当同一个用户对同一个商品再次进行下单操作时，会先去redis中查询是否已经存在该秒杀订单&lt;/li&gt;
&lt;li&gt;mysql层面，在订单表中建立用户id和商品id的唯一索引&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分布式会话问题如何判断用户有没有登录&#34;&gt;分布式会话问题(如何判断用户有没有登录)？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;用户登录后，服务端会生成一个UUID交给客户端存入cookie中，之后客户端只需要携带这个cookie来请求数据即可&lt;/li&gt;
&lt;li&gt;同时服务器端会把UUID和用户信息作为键值对存入到redis中，并设置一个过期时间，后续要判断是否登录过时，去redis中获取对应的用户信息就行，能获取到说明已经登录了，如果没有获取到就跳转到登录页面。因为用户信息是缓存在Redis中的，访问多台服务器也不会出现需要登录多次或者登录无效的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;用户秒杀流程登录-输入验证码-立即秒杀-创建真实秒杀地址-判断是否重复抢购-预减库存-创建消息已在排队-消费者消费消息-判断是否重复抢购-更新库存生成订单并放到redis中-用户进入排队状态后轮询查看是否抢购成功&#34;&gt;用户秒杀流程（登录-输入验证码-立即秒杀-创建真实秒杀地址-判断是否重复抢购-预减库存-创建消息（已在排队）-消费者消费消息-判断是否重复抢购-更新库存、生成订单并放到redis中-用户进入排队状态后轮询查看是否抢购成功）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;首先用户在客户端键入用户名和密码，然后前端会使用盐和md5对用户输入的密码进行一次加密，然后将用户名和加密后的密码传输到服务器端&lt;/li&gt;
&lt;li&gt;服务端首先会用正则表达式验证用户名的合法性（手机号是否合法），然后根据手机号去数据库获取用户信息，若为空说明未注册&lt;/li&gt;
&lt;li&gt;然后服务器会对前端发来的密码二次加密，和数据库中取出来的密码进行比对，如果不一致，说明密码错误（密码在存入数据库前还会进行一次加密）&lt;/li&gt;
&lt;li&gt;比对成功，则登陆成功，同时通过uuid生成一个token放入到cookie中返回给客户端，还将token作为key，用户信息作为val存入redis，解决分布式session问题&lt;/li&gt;
&lt;li&gt;登陆成功后，会跳转到商品列表页面，同时会将商品列表页存入到redis中（存放的为String）过期时间60s&lt;/li&gt;
&lt;li&gt;点击商品详情后，会判断秒杀是否开始以及结束，同时返回商品的详情信息，在没有开始秒杀之前不能购买，秒杀时间是以服务器的时间为准，客户端读取一次服务器当前的时间，然后每过一秒将剩余时间减1&lt;/li&gt;
&lt;li&gt;可以秒杀后，用户先点击刷新验证码，这时会生成验证码并将正确答案存入Redis中，然后用户在表单中填写验证码&lt;/li&gt;
&lt;li&gt;用户点击了立即秒杀之后&lt;/li&gt;
&lt;li&gt;首先在拦截器里 判断用户登录状态（从cookie中获取token 在Redis中查是否存在以这个token为键的用户）如果登录过 将用户存放在ThreadLocals这个map里 Controller层的方法使用User时可以直接从TreadLocals中获取 不用再写通过cookie Redis获取user的逻辑 访问接口结束后 手动Remove TreadLocal变量 防止内存泄漏&lt;/li&gt;
&lt;li&gt;接口限流 统计用户短时间内发送请求的次数 如果超过阈值就拒绝请求&lt;/li&gt;
&lt;li&gt;进行验证码校验（将前端传过来的验证码结果与Redis中存储的验证码进行比对 一致就通过）&lt;/li&gt;
&lt;li&gt;创建真实的秒杀地址（UUID加盐再用MD5加密）将秒杀地址存到Redis中&lt;/li&gt;
&lt;li&gt;然后到达秒杀接口、判断用户登录状态-验证秒杀地址(前端传过来的和存在Redis中的是否一致)-判断是否重复抢购（Redis中是否有该用户-商品的键值对）- 是否有内存标记（某商品Redis库存为0后 就将该商品ID存入一个Map中（商品id-true） 减少对Redis的访问 项目启动时 除了商品库存放到Redis里 还把商品-false存到Map里）- 通过lua脚本预减Redis库存 - 然后创建一个消息发送到消息队列中-告知用户已进入排队状态&lt;/li&gt;
&lt;li&gt;之后就是等待消息队列将消息投递给消费者进行消费 消费时先判断是否重复抢购 如果Redis中没有该用户购买该商品的记录 没有的话查询数据库相关商品的库存 库存足够就执行下单操作&lt;/li&gt;
&lt;li&gt;数据库中秒杀商品表减库存 更新库存和生成订单放在一个事务里 更新用update语句 返回值是影响的行数 如果行数为0 说明库存已经为零 就把Map中该商品的标志置为true（客户端轮询的时候如果发现时true 就是商品已经抢完了 秒杀失败）如果减库存成功就生成订单和秒杀订单 并把秒杀订单放入Redis中 用来检验之后是否重复下单&lt;/li&gt;
&lt;li&gt;在用户进入排队状态之后 可以轮询查看是否抢购成功 如果秒杀订单中存在该用户订单 则秒杀成功&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;redis都做了什么&#34;&gt;Redis都做了什么&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;项目启动时将数据库中参与到秒杀活动的商品id作为值商品库存作为value存储到redis中 用来预减库存&lt;/li&gt;
&lt;li&gt;用户登录后将服务器生成的UUID作为键 用户ID作为值存储到Redis中实现分布式会话。（服务器生成UUID发送给客户端 客户端存储到Cookie中
之后携带Cookie俩访问服务器 在Redis中找到UUID键值对就说明登录了）&lt;/li&gt;
&lt;li&gt;拦截器那边 将客户端请求的URI和用户ID作为键 短期内发送请求的数量作为值 存储到Redis中 该值超过阈值就限制用户访问 达到接口限流目的&lt;/li&gt;
&lt;li&gt;用户点击刷新验证码，存储生成的验证码结果，之后和前端传过来的用户输入的验证码结果进行校验&lt;/li&gt;
&lt;li&gt;用户提交秒杀请求后会先生成真实的秒杀地址 即MD5(UUID + 盐)，然后把字符串Path + 用户ID + 商品ID作为键 秒杀地址作为值存到Redis中（过期时间60s） 之后进行秒杀地址的校验&lt;/li&gt;
&lt;li&gt;生成秒杀订单后 将用户ID+商品ID作为键 秒杀订单作为值存储到Redis中，在Redis预减库存之前和消费者消费消息时（在操作数据库前）都会验证Redis中是否已经存在该用户对该商品的订单 防止用户重复下单（Redis预减库存时候判断是为了防止已经生成订单后 用户又发送了秒杀请求 减少对Redis的访问 消费者消费消息前进行判断是为了防止生成订单之前某用户重复发送了秒杀请求或者消息队列中的消息重复消费的情况）&lt;/li&gt;
&lt;li&gt;用到内存缓存的地方：在项目启动时把涉及到的商品ID和false作为键值对存到内存中，当Redis中某商品的库存为零时 把Map中该商品的值修改为True 在访问Redis进行预减库存前先判断Map中该商品的值是否为true 如果为true则说明Redis中没有库存了&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;如果项目中的redis挂掉如何减轻数据库的压力&#34;&gt;如果项目中的Redis挂掉，如何减轻数据库的压力？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;采用主从模式和哨兵模式&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数据库中的表是怎么设计的&#34;&gt;数据库中的表是怎么设计的？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;秒杀商品表：秒杀商品的id、秒杀库存、秒杀价格&lt;/li&gt;
&lt;li&gt;秒杀订单表：存放用户id、商品id和订单id&lt;/li&gt;
&lt;li&gt;用户表：存放用户信息、id、密码、盐（用于加密）&lt;/li&gt;
&lt;li&gt;订单表：存放用户id，商品id和等详细的订单信息&lt;/li&gt;
&lt;li&gt;商品表：商品id，库存、价格&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数据库修改库存的sql&#34;&gt;数据库修改库存的sql？&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;update&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;sTable&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;set&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stock&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;where&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;goodId&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;and&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stock&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;cookie的不安全性&#34;&gt;cookie的不安全性&lt;/h2&gt;
&lt;p&gt;cookie是存储在浏览器客户端的，有cookie就能获取token 有token就能去Redis中获取用户对象，即访问服务器携带了谁的cookie，就是登录了谁的账号。
优化：可以用Session来保存用户信息，session保存在服务器端，这样安全性高一些。&lt;/p&gt;
&lt;h2 id=&#34;rabbitmq消息的可靠性保证消息模型有-队列模型-发布订阅&#34;&gt;RabbitMQ消息的可靠性保证（消息模型有 队列模型 发布订阅）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;工作模式有：简单模式（发送到队列，一个消费者处理）、工作队列模式（发送到队列，多个消费者处理）、发布订阅模式（发送到交换机广播给绑定的队列）、路由模式（发送到交换机，再发给符合路由匹配的队列）、主题模式（类似路由模式，支持模式匹配）&lt;/li&gt;
&lt;li&gt;保证生产者发送的消息到达MQ
&lt;ul&gt;
&lt;li&gt;保证生产者将消息发送到MQ，生产者发送消息后可能由于网络问题导致消息没有送达到MQ，但这时候MQ不知道消息没有发送成功，这就导致了消息的丢失。为了解决这个问题MQ引入了事务机制和发送方确认机制，事务机制过于消耗性能，一般采用后者。过程是MQ开启发送发确认机制，在生产者发送消息前，先将消息写入数据库的消息表中，状态标记为发送中，然后生产者发送消息，当生产者收到MQ的确认消息时，将数据库中消息的状态改为发送成功，还需要开启一个定时任务，扫描消息表，将其中未发送成功的消息重新发送，重复多次后仍未成功，则标记消息状态为发送失败，然后做人工处理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MQ收到消息后保证分发到消息对应的Exchange
&lt;ul&gt;
&lt;li&gt;消息找不到对应的Exchange&lt;/li&gt;
&lt;li&gt;或找到了对应的Exchange，但是找不到对应的queue，这两种情况都可以用MQ的Mandatory参数来解决，它可以设置消息投递保证可靠性的话就选第二种，然后再进一步处理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Exchange分发消息入队后保证消息的持久性
&lt;ul&gt;
&lt;li&gt;做消息、队列、Exchange的持久化，出现MQ宕机的情况，保证消息能够恢复&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;消费者收到消息后保证消息的正确消费
&lt;ul&gt;
&lt;li&gt;消费者消息确认机制，开启机制后，只要这条消息没有成功消费，无论出现什么情况，这条消息都会被重新放回到死信队列中再次被消费，可以用Redis来保证消息的幂等性，重复的消息会被幂等结构过滤掉&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;死信队列：如果消息消费失败了 或者在消息队列中存活的时间超过了它设定的生存时间 或者消息队列满了 那么就会把消息放到死信队列中重新消费 确保没有被正确消费的消息不被丢弃&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;缓存和数据库的一致性项目中没考虑到缓存和数据库的一致性问题&#34;&gt;缓存和数据库的一致性（项目中没考虑到缓存和数据库的一致性问题）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;引入缓存主要是为了提高性能，必然会造成一定的数据不一致性，如果要
接近强一致性，那只能加锁做互斥并且把更新数据库和更新缓存包装成一个事务，这样就起不到提高性能的作用了，所以我们要做的是保证数据的最终一致性并且尽量减少数据不一致持续的时间。&lt;/li&gt;
&lt;li&gt;处理数据一致性问题可以考虑的方案有 更新数据库+更新缓存、更新数据库+删除缓存两种，更新数据库+更新缓存和先删除缓存再更新数据库在并发场景下无法保证最终一致性，所以采用先更新数据库再删除缓存的策略（缓存失效且写操作早于读操作完成时也会造成数据不一致 但不容易发生）&lt;/li&gt;
&lt;li&gt;如果删除缓存采用同步策略会影响吞吐量，并且在遇到Redis宕机或者项目重启会丢失删除这个操作，所以采用消息队列异步删除缓存，消息队列可以保证消息成功到达队列、入队后消息的持久性、消息成功消费前持续投递&lt;/li&gt;
&lt;li&gt;此外可以采用延时双删的策略，删除缓存（避免读到脏数据），更新主库 延迟一段时间再删除缓存（缺点：延迟时间不好控制）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;采用更新数据库删缓存策略更新成功但是删缓存失败怎么办&#34;&gt;采用更新数据库+删缓存策略，更新成功但是删缓存失败怎么办？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;重试机制：可以引入&lt;strong&gt;消息队列&lt;/strong&gt;，将第二个操作（删除缓存）要操作的数据加入到消息队列，由消费者来操作数据。消息队列有失败重试机制，如果删缓存失败会重试，如果成功就从消息队列中移除（这样做的话发送消息的逻辑会夹杂在业务代码中）&lt;/li&gt;
&lt;li&gt;订阅binlog日志，再删缓存。利用开源的canal中间件，他假装自己是一个mysql主从复制的从节点，订阅了mysql的binlog日志，从binlog日志中可以解析出mysql更新了哪些内容，发送到消息队列，然后再执行删除操作。这个好处是可以减少业务代码的入侵，因为是canal作为生产者给消息队列发送消息，不需要在业务代码中添加消息发送的逻辑。&lt;/li&gt;
&lt;li&gt;为了避免缓存击穿，如果要删除的是热点数据，那么不直接删除，而是把它的生命周期设更短一些，业务方获取该数据时告诉它这是一个脏数据，由业务方自己决定是否使用。&lt;/li&gt;
&lt;li&gt;如果还要进一步降低不一致性 可以更新数据库后同步删除缓存，然后再监听binlog异步删除缓存，同时设置缓存的过期时间（更新越频繁的数据过期时间越短）等操作，但这样会使缓存命中率低。&lt;/li&gt;
&lt;li&gt;此外可以监听从库binlog，防止binlog中间件出现问题影响到主库&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;用户下单完成后就结束了-没有考虑后续的付款等操作&#34;&gt;用户下单完成后就结束了 没有考虑后续的付款等操作&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;如果涉及到付款 则需要考虑下单了但是规定时间内未付款回补数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;限流-令牌桶算法-1&#34;&gt;限流-令牌桶算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;令牌桶算法：固定大小的令牌桶以恒定的速率生成令牌，当令牌消耗速率小于生成的速率时，令牌就会不断增加，直到把桶填满，拿到令牌的用户才能执行后续的操作，以此来实现限流。&lt;/li&gt;
&lt;li&gt;漏桶算法：请求先放到漏桶里，然后以一定的速度放出，当请求流入速度过大时漏桶会直接溢出，溢出的请求就丢弃掉&lt;/li&gt;
&lt;li&gt;二者的区别是漏桶算法能强行改变请求流出漏桶的速度，令牌桶在这个基础上还能允许某种程度的突发传输（只要令牌桶中还有令牌，就可以一直来取，直到桶里没有令牌了）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;保证秒杀请求的幂等性&#34;&gt;保证秒杀请求的幂等性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;虽然做了接口限流 限制用户在短时间内频繁发送秒杀请求 但是这主要是为了缓解Redis服务器的压力 还是无法保证用户发送请求的幂等性 应该在用户第一次秒杀请求预减库存之后 将用户ID-商品ID存入一个set中，在Redis预减库存之前先判断该用户是否已经发送了对该商品的秒杀请求 如果有了就返回请勿重复秒杀 防止一个用户对同一个商品多次预减库的情况。这样也可以降低Redis服务器的压力，就不需要限制用户短期内的点击次数了。相当于是实现消息队列生产端的幂等性。
在有RabbitMQ消息可靠性保证的一系列机制情况下，仍然可能会出现消息被重复消费的情况，这时可以&lt;strong&gt;在查询数据库并生成订单之前校验该用户对该商品的秒杀订单是否已经存在&lt;/strong&gt;，如果存在就直接返回。相当于是实现消息队列消费端的幂等性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;商品列表&#34;&gt;商品列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;登陆成功后，会跳转到商品列表页面&lt;/li&gt;
&lt;li&gt;同时会将商品列表页存入到redis中（存放的为String）过期时间60s&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;商品详情页面&#34;&gt;商品详情页面&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;先会执行goodsController中的detail，这个接口中会判断秒杀是否开始以及结束，同时返回商品的详情信息&lt;/li&gt;
&lt;li&gt;验证码部分：
&lt;ul&gt;
&lt;li&gt;访问接口SecKillController中的/seckill/captcha&lt;/li&gt;
&lt;li&gt;会在服务器端生成一个验证码，并将验证码的结果存放的redis中（key为用户id+商品id，val为验证码的结果，过期时间300s）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;秒杀接口地址隐藏部分：
&lt;ul&gt;
&lt;li&gt;在前端中暴露出来的秒杀按钮，指向的并不是服务器端真正执行秒杀的接口，而是指向了秒杀接口中获取秒杀地址的接口&lt;/li&gt;
&lt;li&gt;在/path中会首先对验证码进行校验，如果验证码错误的话，是不会生成秒杀地址的；&lt;/li&gt;
&lt;li&gt;创建的秒杀地址为：uuid，同时会将用户id、商品id作为键，秒杀地址作为值，存入到redis中；同时会将秒杀地址发送回客户端，客户端根据获取到的秒杀地址重新去请求秒杀接口，真正的秒杀接口会去校验这个秒杀接口的合法性，合法了才会执行后续逻辑&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;redis预减库存解决超卖问题
&lt;ul&gt;
&lt;li&gt;redis本身是单线程的&lt;/li&gt;
&lt;li&gt;使用lua脚本，将判断库存是否大于0和库存减一操作合并为一个原子操作&lt;/li&gt;
&lt;li&gt;如果redis预减库存成功，直接向用户返回一个正在查询秒杀结果的信息，前端此时就回去轮询查看结果。同时会生成一个秒杀信息，通过rabbitMQ异步下单，异步下单操作成功的同时会将用户id、商品id作为key，将订单信息作为val存放到redis中，后续如果同一个用户对同一件商品要进行秒杀时，会去查询redis，如果发现已经秒杀过了，就会提示重复秒杀&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;补货逻辑&#34;&gt;补货逻辑&lt;/h2&gt;
&lt;p&gt;1.等凌晨流量小的时候补货&lt;/p&gt;
&lt;p&gt;2.延迟消息队列&lt;/p&gt;
&lt;p&gt;3.任务调度框架，Quartz&lt;/p&gt;
&lt;h2 id=&#34;真实秒杀地址怎么生成&#34;&gt;真实秒杀地址怎么生成&lt;/h2&gt;
&lt;p&gt;在验证码校验通过之后，会生成真实的秒杀地址&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;seckillpath:+userid+goodsid为key，随机生成uuid为value，存在redis中。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;消息队列怎么配置&#34;&gt;消息队列怎么配置&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;配置交换机路由&lt;/li&gt;
&lt;li&gt;建立MQSender类，向配置的交换机路由发送消息&lt;/li&gt;
&lt;li&gt;建立MQReceiver类，监听MQ队列&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Extendible Hash</title>
      <link>https://hyflying.github.io/post/cmu15445-p2/</link>
      <pubDate>Fri, 01 Mar 2024 00:00:00 +0000</pubDate>
      <guid>https://hyflying.github.io/post/cmu15445-p2/</guid>
      <description>&lt;h1 id=&#34;project2-extendible-hash&#34;&gt;Project2 Extendible Hash&lt;/h1&gt;
&lt;h1 id=&#34;算法简述&#34;&gt;算法简述&lt;/h1&gt;
&lt;p&gt;两个重要概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;directory：目录页，根据取最低的global depth位bits，得到key对应的bucket&lt;/li&gt;
&lt;li&gt;bucket：存hashed key&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三个重要变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;global depth：规定看最低多少位bits，global depth为n，有2^n个directories&lt;/li&gt;
&lt;li&gt;local depth：bucket的depth，规定bucket只看最低local depth位的bits来分配hashed key放到哪个bucket中，local depth不能大于global depth&lt;/li&gt;
&lt;li&gt;bucket size：规定了一个bucket里最多放多少个hashed key&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;insert一个key&#34;&gt;insert一个key&lt;/h2&gt;
&lt;p&gt;讨论最常见的三种情况。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;bucket没有满&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这种情况下直接插入就行&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;bucket满了，但是bucket的local depth还是小于global depth&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;此时需要split bucket，并将local depth+1，更新directory指向local depth的指针，同时根据新的local depth重新分配被分裂桶中的元素以及新加的元素&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;bucket满了，并且bucket的local depth等于global depth&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为local depth不能大于global depth，因此这种情况下，需要global depth先加1，global depth加1之后，directories要✖️2，就是复制一份原来的directories，bucket的local depth也要加1，然后split bucket，directory指向分裂的buckets的指针要重新分配，分裂的buckets里的hashed key也要重新分配。&lt;/p&gt;
&lt;h1 id=&#34;项目代码简述&#34;&gt;项目代码简述&lt;/h1&gt;
&lt;h2 id=&#34;extendiblehtabledirectorypage&#34;&gt;ExtendibleHTableDirectoryPage&lt;/h2&gt;
&lt;h3 id=&#34;成员变量&#34;&gt;成员变量&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;max_depth_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;global_depth_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;uint8_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;local_depths_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HTABLE_DIRECTORY_ARRAY_SIZE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//local depth数组
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;page_id_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bucket_page_ids_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HTABLE_DIRECTORY_ARRAY_SIZE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//指向对应的bucket
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;函数&#34;&gt;函数&lt;/h3&gt;
&lt;p&gt;这里的bucket_idx是根据key以及global depth hash得来的，指向具体的bucket&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ExtendibleHTableDirectoryPage&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GetSplitImageIndex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bucket_idx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;//GetSplitImageIndex要在local depth + 1之后。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;local_depth&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;local_depths_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bucket_idx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bucket_idx&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;^&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1U&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;local_depth&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;extendiblehtablebucketpage&#34;&gt;ExtendibleHTableBucketPage&lt;/h2&gt;
&lt;p&gt;这里的bucket_idx是指向当前桶里的某个元素的idx，桶里元素是key，value的pair&lt;/p&gt;
&lt;h2 id=&#34;extendiblehtableheaderpage&#34;&gt;ExtendibleHTableHeaderPage&lt;/h2&gt;
&lt;p&gt;创建一个headerPage，不能用构造函数。要从bpm中拿到新的一个page&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;page_id_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;header_page_id&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;INVALID_PAGE_ID&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;BasicPageGuard&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;header_guard&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bpm_&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;NewPageGuarded&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;header_page_id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;header_page_&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;header_guard&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;AsMut&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ExtendibleHTableHeaderPage&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;header_page_&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Init&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;header_max_depth_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;pageguard&#34;&gt;PageGuard&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;auto BasicPageGuard::UpgradeWrite() -&amp;gt; WritePageGuard
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;auto BasicPageGuard::UpgradeRead() -&amp;gt; ReadPageGuard
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;page先加对应的锁，然后再生成Read/WritePageGuard,原先的bpm_和page_置空&lt;/p&gt;
&lt;h1 id=&#34;bug记录&#34;&gt;Bug记录&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;BufferPoolManager的pool size很小的时候，如果fetch完页面，用完之后不及时释放锁，可能会导致pool里所有页面都是锁着的，而此时如果再fetch新页面，会有问题。因此用完页面以后要及时释放&lt;/li&gt;
&lt;li&gt;GetValue的时候，可能访问的directory_page或者bucket_page都不存在，那这种情况下返回的page_id会是IN_VALID_PAGE_ID,需要直接返回false&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>BufferPoolManager</title>
      <link>https://hyflying.github.io/post/cmu15445-p1/</link>
      <pubDate>Mon, 05 Feb 2024 00:00:00 +0000</pubDate>
      <guid>https://hyflying.github.io/post/cmu15445-p1/</guid>
      <description>&lt;h1 id=&#34;project1-bufferpoolmanager&#34;&gt;Project1 BufferPoolManager&lt;/h1&gt;
&lt;h2 id=&#34;lru-k&#34;&gt;LRU-K&lt;/h2&gt;
&lt;p&gt;LRU-K算法是干什么的？它是一个页面置换算法，系统将虚拟内存地址划分为各个虚拟页(page_id),将物理内存地址划分为物理页(frame_id)，当物理内存满了以后，就得决定该淘汰哪个虚拟页，从而能够加载新的虚拟页。&lt;/p&gt;
&lt;h3 id=&#34;成员变量&#34;&gt;成员变量&lt;/h3&gt;
&lt;p&gt;LRUKReplacer成员变量&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::unordered_map&amp;lt;frame_id_t, LRUKNode&amp;gt; node_store_;&lt;/code&gt; frame_id具体存的LRUKNode&lt;/p&gt;
&lt;p&gt;&lt;code&gt;size_t current_timestamp_{0};&lt;/code&gt; 当前的时间戳，用每加入一个新页面自增来模拟&lt;/p&gt;
&lt;p&gt;&lt;code&gt;size_t curr_size_{0};&lt;/code&gt; 当前可淘汰的(evictable)页面数量&lt;/p&gt;
&lt;p&gt;&lt;code&gt;size_t replacer_size_;&lt;/code&gt; max size of frame&lt;/p&gt;
&lt;p&gt;&lt;code&gt;size_t k_;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::mutex latch_;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;LRUKNode成员变量&lt;/p&gt;
&lt;p&gt;&lt;code&gt;frame_id_t fid_;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::list&amp;lt;size_t&amp;gt; history_;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;size_t k_;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bool is_evictable_{false};&lt;/code&gt; 标记页面是否可以被淘汰&lt;/p&gt;
&lt;h3 id=&#34;函数&#34;&gt;函数&lt;/h3&gt;
&lt;p&gt;LRUKNode函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;auto GetKDistance(size_t cur) -&amp;gt; uint64_t&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;计算时间差，如果该页面的历史次数小于k次，则为正无穷，如果大于等于k次，则计算当前时间戳与第k次的时间差，并返回。&lt;/p&gt;
&lt;p&gt;LRUKReplacer函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;auto Evict(frame_id_t *frame_id) -&amp;gt; bool;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;淘汰可淘汰的页面中(is_evictabe = true)，时间距离最远的page&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;void RecordAccess(frame_id_t frame_id, AccessType access_type = AccessType::*Unknown*);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;记录访问了哪个frame页面。考虑节点是否已经存在，如果不存在且replacer的size已经满的情况下访问失败，否则如果存在history_list加入当前时间戳，然后current_timestamp自增；如果不存在先建立新的LRUKNode节点，再做后续的步骤&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;void LRUKReplacer::SetEvictable(frame_id_t frame_id, bool set_evictable)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;该函数会影响curr_size的大小，因为curr_size返回的是当前可淘汰页面的数量，如果通过该函数把以前false的设置为true了，那curr_size要自增，反之则自减&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;void LRUKReplacer::Remove(frame_id_t frame_id)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;驱逐某个页面。首先要保证该页面是否存在，如果存在还要保证该页面是否可以被驱逐，在前两个条件都满足的情况下，可以驱逐这个页面，curr_size要减1。&lt;/p&gt;
&lt;h2 id=&#34;bufferpoolmanager&#34;&gt;BufferPoolManager&lt;/h2&gt;
&lt;h3 id=&#34;成员变量-1&#34;&gt;成员变量&lt;/h3&gt;
&lt;p&gt;BufferPoolManager成员变量&lt;/p&gt;
&lt;p&gt;&lt;code&gt;const size_t pool_size_;&lt;/code&gt; bufferpool的size，代表了可以有多少页面在bufferpool里&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::atomic&amp;lt;page_id_t&amp;gt; next_page_id_ = 0;&lt;/code&gt; 下一个page_id，从0开始保持自增&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Page *pages_;&lt;/code&gt; 一个数组，存放的是bufferpool中的页面，根据frame_id得到当前frame保存的page&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::unique_ptr&amp;lt;DiskScheduler&amp;gt; disk_scheduler_ __attribute__((__unused__));&lt;/code&gt; 负责向磁盘读写页面内容&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::unordered_map&amp;lt;page_id_t, frame_id_t&amp;gt; page_table_;&lt;/code&gt; 记录虚拟页面对应的物理内存页面&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::unique_ptr&amp;lt;LRUKReplacer&amp;gt; replacer_;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::list&amp;lt;frame_id_t&amp;gt; free_list_;&lt;/code&gt; 空闲的物理页面，如果有就不需要考虑替换哪个页面了&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::mutex latch_;&lt;/code&gt; latch 是一种轻量级的同步机制，用于保护短期操作，而 lock 是一种用于控制长期访问共享资源的同步机制，通常用于实现事务的隔离和一致性。&lt;/p&gt;
&lt;p&gt;DiskScheduler&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DiskManager *disk_manager_ __attribute__((__unused__));&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Channel&amp;lt;std::optional&amp;lt;DiskRequest&amp;gt;&amp;gt; request_queue_;&lt;/code&gt; 处理请求队列&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::optional&amp;lt;std::thread&amp;gt; background_thread_;&lt;/code&gt; 在后台线程处理请求&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;DiskRequest&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/** Flag indicating whether the request is a write or a read. */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;is_write_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/**
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;   *  Pointer to the start of the memory location where a page is either:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;   *   1. being read into from disk (on a read).
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;   *   2. being written out to disk (on a write).
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;   */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/** ID of the page being read from / written to disk. */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;page_id_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;page_id_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/** Callback used to signal to the request issuer when the request has been completed. */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;promise&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;callback_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;函数-1&#34;&gt;函数&lt;/h3&gt;
&lt;p&gt;BufferPoolManager&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构造函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;构造函数需要做三件事，首先初始化replacer，第二根据pool_size初始化pages数组，最后把所有页面都放入free_list中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;auto NewPage(page_id_t *page_id) -&amp;gt; Page *;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;新生成一个虚拟页面，虚拟页面得有对应的物理页面。所以需要判断free_list有无可用的物理页面，如果有就直接取空闲页面，如果没有得调用replacer根据LRUK驱逐一个页面。如果驱逐出去的页面是dirty的，那我们得把这个页面写回给磁盘。然后要将新页面的pin_count设置为1，调用&lt;/p&gt;
&lt;p&gt;replacer_-&amp;gt;RecordAccess(frame_id);和replacer_-&amp;gt;SetEvictable(frame_id, false);两个函数，因为生成了新页面以后肯定是要用的，所以要调用这两个函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;auto NewPageGuarded(page_id_t *page_id) -&amp;gt; BasicPageGuard;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;该函数在project2中完成，用于管理pin_count，不需要手动unpin&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;auto FetchPage(page_id_t page_id, AccessType access_type = AccessType::*Unknown*) -&amp;gt; Page *;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果缓冲池中有该page，可以直接取到page，pin_count加1，调用&lt;/p&gt;
&lt;p&gt;replacer_-&amp;gt;RecordAccess(frame_id);replacer_-&amp;gt;SetEvictable(frame_id, false);然后返回该page。&lt;/p&gt;
&lt;p&gt;如果不存在，先确定page加载到哪个frame页面，然后从磁盘读取该page数据，加载到frame中。这一步其实与NewPage逻辑有点相似，只不过NewPage只要返回空的page就可以，但是fetchPage得返回从磁盘中读取的page&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;auto UnpinPage(page_id_t page_id, bool is_dirty, AccessType access_type = AccessType::*Unknown*) -&amp;gt; bool;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过is_dirty参数告诉bpm该页面是否被修改过，然后需要对引用次数减1。如果引用次数为0，那么调用replacer_-&amp;gt;SetEvictable(frame_id, true);说明该页面已经被用完了，可以被驱逐了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;auto FlushPage(page_id_t page_id) -&amp;gt; bool;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过DiskScheduler将脏页面写回磁盘&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;promise&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;disk_scheduler_&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CreatePromise&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;future&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;promise&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get_future&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;disk_scheduler_&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Schedule&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;({&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;page&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GetData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;page&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GetPageId&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;move&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;promise&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)});&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;future&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>An example preprint / working paper</title>
      <link>https://hyflying.github.io/publication/preprint/</link>
      <pubDate>Sun, 07 Apr 2019 00:00:00 +0000</pubDate>
      <guid>https://hyflying.github.io/publication/preprint/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Create your slides in Markdown - click the &lt;em&gt;Slides&lt;/em&gt; button to check out the example.
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Add the publication&amp;rsquo;s &lt;strong&gt;full text&lt;/strong&gt; or &lt;strong&gt;supplementary notes&lt;/strong&gt; here. You can use rich formatting such as including &lt;a href=&#34;https://docs.hugoblox.com/content/writing-markdown-latex/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;code, math, and images&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Slides</title>
      <link>https://hyflying.github.io/slides/example/</link>
      <pubDate>Tue, 05 Feb 2019 00:00:00 +0000</pubDate>
      <guid>https://hyflying.github.io/slides/example/</guid>
      <description>&lt;h1 id=&#34;create-slides-in-markdown-with-hugo-blox-builder&#34;&gt;Create slides in Markdown with Hugo Blox Builder&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://hugoblox.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hugo Blox Builder&lt;/a&gt; | &lt;a href=&#34;https://docs.hugoblox.com/content/slides/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Documentation&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;features&#34;&gt;Features&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Efficiently write slides in Markdown&lt;/li&gt;
&lt;li&gt;3-in-1: Create, Present, and Publish your slides&lt;/li&gt;
&lt;li&gt;Supports speaker notes&lt;/li&gt;
&lt;li&gt;Mobile friendly slides&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;controls&#34;&gt;Controls&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Next: &lt;code&gt;Right Arrow&lt;/code&gt; or &lt;code&gt;Space&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Previous: &lt;code&gt;Left Arrow&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Start: &lt;code&gt;Home&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Finish: &lt;code&gt;End&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Overview: &lt;code&gt;Esc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Speaker notes: &lt;code&gt;S&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Fullscreen: &lt;code&gt;F&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Zoom: &lt;code&gt;Alt + Click&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://revealjs.com/pdf-export/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PDF Export&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;code-highlighting&#34;&gt;Code Highlighting&lt;/h2&gt;
&lt;p&gt;Inline code: &lt;code&gt;variable&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Code block:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;porridge&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;blueberry&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;porridge&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;blueberry&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Eating...&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h2 id=&#34;math&#34;&gt;Math&lt;/h2&gt;
&lt;p&gt;In-line math: $x + y = z$&lt;/p&gt;
&lt;p&gt;Block math:&lt;/p&gt;
&lt;p&gt;$$
f\left( x \right) = ;\frac{{2\left( {x + 4} \right)\left( {x - 4} \right)}}{{\left( {x + 4} \right)\left( {x + 1} \right)}}
$$&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;fragments&#34;&gt;Fragments&lt;/h2&gt;
&lt;p&gt;Make content appear incrementally&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;{{% fragment %}} One {{% /fragment %}}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;{{% fragment %}} **Two** {{% /fragment %}}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;{{% fragment %}} Three {{% /fragment %}}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Press &lt;code&gt;Space&lt;/code&gt; to play!&lt;/p&gt;
&lt;span class=&#34;fragment &#34; &gt;
  One
&lt;/span&gt;
&lt;span class=&#34;fragment &#34; &gt;
  &lt;strong&gt;Two&lt;/strong&gt;
&lt;/span&gt;
&lt;span class=&#34;fragment &#34; &gt;
  Three
&lt;/span&gt;
&lt;hr&gt;
&lt;p&gt;A fragment can accept two optional parameters:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;class&lt;/code&gt;: use a custom style (requires definition in custom CSS)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;weight&lt;/code&gt;: sets the order in which a fragment appears&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;speaker-notes&#34;&gt;Speaker Notes&lt;/h2&gt;
&lt;p&gt;Add speaker notes to your presentation&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-markdown&#34; data-lang=&#34;markdown&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;{{% speaker_note %}}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;-&lt;/span&gt; Only the speaker can read these notes
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;-&lt;/span&gt; Press &lt;span class=&#34;sb&#34;&gt;`S`&lt;/span&gt; key to view
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  {{% /speaker_note %}}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Press the &lt;code&gt;S&lt;/code&gt; key to view the speaker notes!&lt;/p&gt;
&lt;aside class=&#34;notes&#34;&gt;
  &lt;ul&gt;
&lt;li&gt;Only the speaker can read these notes&lt;/li&gt;
&lt;li&gt;Press &lt;code&gt;S&lt;/code&gt; key to view&lt;/li&gt;
&lt;/ul&gt;

&lt;/aside&gt;
&lt;hr&gt;
&lt;h2 id=&#34;themes&#34;&gt;Themes&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;black: Black background, white text, blue links (default)&lt;/li&gt;
&lt;li&gt;white: White background, black text, blue links&lt;/li&gt;
&lt;li&gt;league: Gray background, white text, blue links&lt;/li&gt;
&lt;li&gt;beige: Beige background, dark text, brown links&lt;/li&gt;
&lt;li&gt;sky: Blue background, thin dark text, blue links&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;night: Black background, thick white text, orange links&lt;/li&gt;
&lt;li&gt;serif: Cappuccino background, gray text, brown links&lt;/li&gt;
&lt;li&gt;simple: White background, black text, blue links&lt;/li&gt;
&lt;li&gt;solarized: Cream-colored background, dark green text, blue links&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;

&lt;section data-noprocess data-shortcode-slide
  
      
      data-background-image=&#34;/media/boards.jpg&#34;
  &gt;

&lt;h2 id=&#34;custom-slide&#34;&gt;Custom Slide&lt;/h2&gt;
&lt;p&gt;Customize the slide style and background&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-markdown&#34; data-lang=&#34;markdown&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;{{&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nt&#34;&gt;slide&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;background-image&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;/media/boards.jpg&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;}}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;{{&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nt&#34;&gt;slide&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;background-color&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;#0000FF&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;}}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;{{&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nt&#34;&gt;slide&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;my-style&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;}}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h2 id=&#34;custom-css-example&#34;&gt;Custom CSS Example&lt;/h2&gt;
&lt;p&gt;Let&amp;rsquo;s make headers navy colored.&lt;/p&gt;
&lt;p&gt;Create &lt;code&gt;assets/css/reveal_custom.css&lt;/code&gt; with:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-css&#34; data-lang=&#34;css&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;reveal&lt;/span&gt; &lt;span class=&#34;nt&#34;&gt;section&lt;/span&gt; &lt;span class=&#34;nt&#34;&gt;h1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;reveal&lt;/span&gt; &lt;span class=&#34;nt&#34;&gt;section&lt;/span&gt; &lt;span class=&#34;nt&#34;&gt;h2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;reveal&lt;/span&gt; &lt;span class=&#34;nt&#34;&gt;section&lt;/span&gt; &lt;span class=&#34;nt&#34;&gt;h3&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;color&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;navy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h1 id=&#34;questions&#34;&gt;Questions?&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://discord.gg/z8wNYzb&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ask&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.hugoblox.com/content/slides/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Documentation&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Example Project</title>
      <link>https://hyflying.github.io/project/example/</link>
      <pubDate>Wed, 27 Apr 2016 00:00:00 +0000</pubDate>
      <guid>https://hyflying.github.io/project/example/</guid>
      <description>&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.&lt;/p&gt;
&lt;p&gt;Nullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.&lt;/p&gt;
&lt;p&gt;Cras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.&lt;/p&gt;
&lt;p&gt;Suspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.&lt;/p&gt;
&lt;p&gt;Aliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>External Project</title>
      <link>https://hyflying.github.io/project/external-project/</link>
      <pubDate>Wed, 27 Apr 2016 00:00:00 +0000</pubDate>
      <guid>https://hyflying.github.io/project/external-project/</guid>
      <description></description>
    </item>
    
    <item>
      <title>An example journal article</title>
      <link>https://hyflying.github.io/publication/journal-article/</link>
      <pubDate>Tue, 01 Sep 2015 00:00:00 +0000</pubDate>
      <guid>https://hyflying.github.io/publication/journal-article/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Click the &lt;em&gt;Cite&lt;/em&gt; button above to demo the feature to enable visitors to import publication metadata into their reference management software.
  &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Create your slides in Markdown - click the &lt;em&gt;Slides&lt;/em&gt; button to check out the example.
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Add the publication&amp;rsquo;s &lt;strong&gt;full text&lt;/strong&gt; or &lt;strong&gt;supplementary notes&lt;/strong&gt; here. You can use rich formatting such as including &lt;a href=&#34;https://docs.hugoblox.com/content/writing-markdown-latex/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;code, math, and images&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>An example conference paper</title>
      <link>https://hyflying.github.io/publication/conference-paper/</link>
      <pubDate>Mon, 01 Jul 2013 00:00:00 +0000</pubDate>
      <guid>https://hyflying.github.io/publication/conference-paper/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Click the &lt;em&gt;Cite&lt;/em&gt; button above to demo the feature to enable visitors to import publication metadata into their reference management software.
  &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Create your slides in Markdown - click the &lt;em&gt;Slides&lt;/em&gt; button to check out the example.
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Add the publication&amp;rsquo;s &lt;strong&gt;full text&lt;/strong&gt; or &lt;strong&gt;supplementary notes&lt;/strong&gt; here. You can use rich formatting such as including &lt;a href=&#34;https://docs.hugoblox.com/content/writing-markdown-latex/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;code, math, and images&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
