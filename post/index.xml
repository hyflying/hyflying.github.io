<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts | Yanfei Huang</title>
    <link>http://localhost:1313/post/</link>
      <atom:link href="http://localhost:1313/post/index.xml" rel="self" type="application/rss+xml" />
    <description>Posts</description>
    <generator>Hugo Blox Builder (https://hugoblox.com)</generator><language>en-us</language><lastBuildDate>Fri, 01 Mar 2024 00:00:00 +0000</lastBuildDate>
    <image>
      <url>http://localhost:1313/media/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_3.png</url>
      <title>Posts</title>
      <link>http://localhost:1313/post/</link>
    </image>
    
    <item>
      <title>Extendible Hash</title>
      <link>http://localhost:1313/post/cmu15445-p2/</link>
      <pubDate>Fri, 01 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/post/cmu15445-p2/</guid>
      <description>&lt;h1 id=&#34;project2-extendible-hash&#34;&gt;Project2 Extendible Hash&lt;/h1&gt;
&lt;h1 id=&#34;算法简述&#34;&gt;算法简述&lt;/h1&gt;
&lt;p&gt;两个重要概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;directory：目录页，根据取最低的global depth位bits，得到key对应的bucket&lt;/li&gt;
&lt;li&gt;bucket：存hashed key&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三个重要变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;global depth：规定看最低多少位bits，global depth为n，有2^n个directories&lt;/li&gt;
&lt;li&gt;local depth：bucket的depth，规定bucket只看最低local depth位的bits来分配hashed key放到哪个bucket中，local depth不能大于global depth&lt;/li&gt;
&lt;li&gt;bucket size：规定了一个bucket里最多放多少个hashed key&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;insert一个key&#34;&gt;insert一个key&lt;/h2&gt;
&lt;p&gt;讨论最常见的三种情况。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;bucket没有满&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这种情况下直接插入就行&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;bucket满了，但是bucket的local depth还是小于global depth&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;此时需要split bucket，并将local depth+1，更新directory指向local depth的指针，同时根据新的local depth重新分配被分裂桶中的元素以及新加的元素&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;bucket满了，并且bucket的local depth等于global depth&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为local depth不能大于global depth，因此这种情况下，需要global depth先加1，global depth加1之后，directories要✖️2，就是复制一份原来的directories，bucket的local depth也要加1，然后split bucket，directory指向分裂的buckets的指针要重新分配，分裂的buckets里的hashed key也要重新分配。&lt;/p&gt;
&lt;h1 id=&#34;项目代码简述&#34;&gt;项目代码简述&lt;/h1&gt;
&lt;h2 id=&#34;extendiblehtabledirectorypage&#34;&gt;ExtendibleHTableDirectoryPage&lt;/h2&gt;
&lt;h3 id=&#34;成员变量&#34;&gt;成员变量&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;max_depth_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;global_depth_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;uint8_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;local_depths_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HTABLE_DIRECTORY_ARRAY_SIZE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//local depth数组
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;page_id_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bucket_page_ids_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HTABLE_DIRECTORY_ARRAY_SIZE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//指向对应的bucket
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;函数&#34;&gt;函数&lt;/h3&gt;
&lt;p&gt;这里的bucket_idx是根据key以及global depth hash得来的，指向具体的bucket&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ExtendibleHTableDirectoryPage&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GetSplitImageIndex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bucket_idx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;//GetSplitImageIndex要在local depth + 1之后。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;local_depth&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;local_depths_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bucket_idx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bucket_idx&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;^&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1U&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;local_depth&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;extendiblehtablebucketpage&#34;&gt;ExtendibleHTableBucketPage&lt;/h2&gt;
&lt;p&gt;这里的bucket_idx是指向当前桶里的某个元素的idx，桶里元素是key，value的pair&lt;/p&gt;
&lt;h2 id=&#34;extendiblehtableheaderpage&#34;&gt;ExtendibleHTableHeaderPage&lt;/h2&gt;
&lt;p&gt;创建一个headerPage，不能用构造函数。要从bpm中拿到新的一个page&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;page_id_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;header_page_id&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;INVALID_PAGE_ID&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;BasicPageGuard&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;header_guard&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bpm_&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;NewPageGuarded&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;header_page_id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;header_page_&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;header_guard&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;AsMut&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ExtendibleHTableHeaderPage&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;header_page_&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Init&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;header_max_depth_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;pageguard&#34;&gt;PageGuard&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;auto BasicPageGuard::UpgradeWrite() -&amp;gt; WritePageGuard
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;auto BasicPageGuard::UpgradeRead() -&amp;gt; ReadPageGuard
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;page先加对应的锁，然后再生成Read/WritePageGuard,原先的bpm_和page_置空&lt;/p&gt;
&lt;h1 id=&#34;bug记录&#34;&gt;Bug记录&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;BufferPoolManager的pool size很小的时候，如果fetch完页面，用完之后不及时释放锁，可能会导致pool里所有页面都是锁着的，而此时如果再fetch新页面，会有问题。因此用完页面以后要及时释放&lt;/li&gt;
&lt;li&gt;GetValue的时候，可能访问的directory_page或者bucket_page都不存在，那这种情况下返回的page_id会是IN_VALID_PAGE_ID,需要直接返回false&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>BufferPoolManager</title>
      <link>http://localhost:1313/post/cmu15445-p1/</link>
      <pubDate>Mon, 05 Feb 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/post/cmu15445-p1/</guid>
      <description>&lt;h1 id=&#34;project1-bufferpoolmanager&#34;&gt;Project1 BufferPoolManager&lt;/h1&gt;
&lt;h2 id=&#34;lru-k&#34;&gt;LRU-K&lt;/h2&gt;
&lt;p&gt;LRU-K算法是干什么的？它是一个页面置换算法，系统将虚拟内存地址划分为各个虚拟页(page_id),将物理内存地址划分为物理页(frame_id)，当物理内存满了以后，就得决定该淘汰哪个虚拟页，从而能够加载新的虚拟页。&lt;/p&gt;
&lt;h3 id=&#34;成员变量&#34;&gt;成员变量&lt;/h3&gt;
&lt;p&gt;LRUKReplacer成员变量&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::unordered_map&amp;lt;frame_id_t, LRUKNode&amp;gt; node_store_;&lt;/code&gt; frame_id具体存的LRUKNode&lt;/p&gt;
&lt;p&gt;&lt;code&gt;size_t current_timestamp_{0};&lt;/code&gt; 当前的时间戳，用每加入一个新页面自增来模拟&lt;/p&gt;
&lt;p&gt;&lt;code&gt;size_t curr_size_{0};&lt;/code&gt; 当前可淘汰的(evictable)页面数量&lt;/p&gt;
&lt;p&gt;&lt;code&gt;size_t replacer_size_;&lt;/code&gt; max size of frame&lt;/p&gt;
&lt;p&gt;&lt;code&gt;size_t k_;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::mutex latch_;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;LRUKNode成员变量&lt;/p&gt;
&lt;p&gt;&lt;code&gt;frame_id_t fid_;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::list&amp;lt;size_t&amp;gt; history_;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;size_t k_;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bool is_evictable_{false};&lt;/code&gt; 标记页面是否可以被淘汰&lt;/p&gt;
&lt;h3 id=&#34;函数&#34;&gt;函数&lt;/h3&gt;
&lt;p&gt;LRUKNode函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;auto GetKDistance(size_t cur) -&amp;gt; uint64_t&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;计算时间差，如果该页面的历史次数小于k次，则为正无穷，如果大于等于k次，则计算当前时间戳与第k次的时间差，并返回。&lt;/p&gt;
&lt;p&gt;LRUKReplacer函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;auto Evict(frame_id_t *frame_id) -&amp;gt; bool;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;淘汰可淘汰的页面中(is_evictabe = true)，时间距离最远的page&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;void RecordAccess(frame_id_t frame_id, AccessType access_type = AccessType::*Unknown*);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;记录访问了哪个frame页面。考虑节点是否已经存在，如果不存在且replacer的size已经满的情况下访问失败，否则如果存在history_list加入当前时间戳，然后current_timestamp自增；如果不存在先建立新的LRUKNode节点，再做后续的步骤&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;void LRUKReplacer::SetEvictable(frame_id_t frame_id, bool set_evictable)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;该函数会影响curr_size的大小，因为curr_size返回的是当前可淘汰页面的数量，如果通过该函数把以前false的设置为true了，那curr_size要自增，反之则自减&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;void LRUKReplacer::Remove(frame_id_t frame_id)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;驱逐某个页面。首先要保证该页面是否存在，如果存在还要保证该页面是否可以被驱逐，在前两个条件都满足的情况下，可以驱逐这个页面，curr_size要减1。&lt;/p&gt;
&lt;h2 id=&#34;bufferpoolmanager&#34;&gt;BufferPoolManager&lt;/h2&gt;
&lt;h3 id=&#34;成员变量-1&#34;&gt;成员变量&lt;/h3&gt;
&lt;p&gt;BufferPoolManager成员变量&lt;/p&gt;
&lt;p&gt;&lt;code&gt;const size_t pool_size_;&lt;/code&gt; bufferpool的size，代表了可以有多少页面在bufferpool里&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::atomic&amp;lt;page_id_t&amp;gt; next_page_id_ = 0;&lt;/code&gt; 下一个page_id，从0开始保持自增&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Page *pages_;&lt;/code&gt; 一个数组，存放的是bufferpool中的页面，根据frame_id得到当前frame保存的page&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::unique_ptr&amp;lt;DiskScheduler&amp;gt; disk_scheduler_ __attribute__((__unused__));&lt;/code&gt; 负责向磁盘读写页面内容&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::unordered_map&amp;lt;page_id_t, frame_id_t&amp;gt; page_table_;&lt;/code&gt; 记录虚拟页面对应的物理内存页面&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::unique_ptr&amp;lt;LRUKReplacer&amp;gt; replacer_;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::list&amp;lt;frame_id_t&amp;gt; free_list_;&lt;/code&gt; 空闲的物理页面，如果有就不需要考虑替换哪个页面了&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::mutex latch_;&lt;/code&gt; latch 是一种轻量级的同步机制，用于保护短期操作，而 lock 是一种用于控制长期访问共享资源的同步机制，通常用于实现事务的隔离和一致性。&lt;/p&gt;
&lt;p&gt;DiskScheduler&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DiskManager *disk_manager_ __attribute__((__unused__));&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Channel&amp;lt;std::optional&amp;lt;DiskRequest&amp;gt;&amp;gt; request_queue_;&lt;/code&gt; 处理请求队列&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::optional&amp;lt;std::thread&amp;gt; background_thread_;&lt;/code&gt; 在后台线程处理请求&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;DiskRequest&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/** Flag indicating whether the request is a write or a read. */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;is_write_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/**
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;   *  Pointer to the start of the memory location where a page is either:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;   *   1. being read into from disk (on a read).
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;   *   2. being written out to disk (on a write).
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;   */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/** ID of the page being read from / written to disk. */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;page_id_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;page_id_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/** Callback used to signal to the request issuer when the request has been completed. */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;promise&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;callback_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;函数-1&#34;&gt;函数&lt;/h3&gt;
&lt;p&gt;BufferPoolManager&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构造函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;构造函数需要做三件事，首先初始化replacer，第二根据pool_size初始化pages数组，最后把所有页面都放入free_list中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;auto NewPage(page_id_t *page_id) -&amp;gt; Page *;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;新生成一个虚拟页面，虚拟页面得有对应的物理页面。所以需要判断free_list有无可用的物理页面，如果有就直接取空闲页面，如果没有得调用replacer根据LRUK驱逐一个页面。如果驱逐出去的页面是dirty的，那我们得把这个页面写回给磁盘。然后要将新页面的pin_count设置为1，调用&lt;/p&gt;
&lt;p&gt;replacer_-&amp;gt;RecordAccess(frame_id);和replacer_-&amp;gt;SetEvictable(frame_id, false);两个函数，因为生成了新页面以后肯定是要用的，所以要调用这两个函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;auto NewPageGuarded(page_id_t *page_id) -&amp;gt; BasicPageGuard;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;该函数在project2中完成，用于管理pin_count，不需要手动unpin&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;auto FetchPage(page_id_t page_id, AccessType access_type = AccessType::*Unknown*) -&amp;gt; Page *;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果缓冲池中有该page，可以直接取到page，pin_count加1，调用&lt;/p&gt;
&lt;p&gt;replacer_-&amp;gt;RecordAccess(frame_id);replacer_-&amp;gt;SetEvictable(frame_id, false);然后返回该page。&lt;/p&gt;
&lt;p&gt;如果不存在，先确定page加载到哪个frame页面，然后从磁盘读取该page数据，加载到frame中。这一步其实与NewPage逻辑有点相似，只不过NewPage只要返回空的page就可以，但是fetchPage得返回从磁盘中读取的page&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;auto UnpinPage(page_id_t page_id, bool is_dirty, AccessType access_type = AccessType::*Unknown*) -&amp;gt; bool;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过is_dirty参数告诉bpm该页面是否被修改过，然后需要对引用次数减1。如果引用次数为0，那么调用replacer_-&amp;gt;SetEvictable(frame_id, true);说明该页面已经被用完了，可以被驱逐了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;auto FlushPage(page_id_t page_id) -&amp;gt; bool;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过DiskScheduler将脏页面写回磁盘&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;promise&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;disk_scheduler_&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CreatePromise&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;future&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;promise&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get_future&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;disk_scheduler_&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Schedule&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;({&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;page&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GetData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;page&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GetPageId&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;move&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;promise&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)});&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;future&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
  </channel>
</rss>
