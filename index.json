
    
    
    
    
    
    
    
    
    
    
    [{"authors":null,"categories":null,"content":"This is Evan. My tech adventure began after earning dual bachelor’s degrees in Computer Science and Japanese at DLUT. Yes, I can code and say “Hello, World!” in Japanese!\nI joined Meituan as an iOS developer after finishing my undergraduate studies. During the 2022 Shanghai lockdown, our app, Meituan Grocery, became a lifeline for thousands trapped at home. This experience cemented my belief in the power of technology to change lives, one app at a time. Eager to level up my tech skills and broaden my horizons, I bid farewell to Meituan and set sail for the US to pursue my graduate studies.\nI’m currently seeking 2025 new grad opportunities. Feel free to reach out to me for any exciting opportunities. Let’s improve the digital world a better place, one line of code at a time!\n","date":1554595200,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1554595200,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"","publishdate":"0001-01-01T00:00:00Z","relpermalink":"","section":"authors","summary":"This is Evan. My tech adventure began after earning dual bachelor’s degrees in Computer Science and Japanese at DLUT. Yes, I can code and say “Hello, World!” in Japanese!\nI joined Meituan as an iOS developer after finishing my undergraduate studies.","tags":null,"title":"黄燕飞","type":"authors"},{"authors":[],"categories":null,"content":" Click on the Slides button above to view the built-in slides feature. Slides can be added in a few ways:\nCreate slides using Hugo Blox Builder’s Slides feature and link using slides parameter in the front matter of the talk file Upload an existing slide deck to static/ and link using url_slides parameter in the front matter of the talk file Embed your slides (e.g. Google Slides) or presentation video on this page using shortcodes. Further event details, including page elements such as image galleries, can be added to the body of this page.\n","date":1906549200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1906549200,"objectID":"a8edef490afe42206247b6ac05657af0","permalink":"https://hyflying.github.io/talk/example-talk/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/talk/example-talk/","section":"event","summary":"An example talk using Hugo Blox Builder's Markdown slides feature.","tags":[],"title":"Example Talk","type":"event"},{"authors":null,"categories":null,"content":"GitHub link: https://github.com/hyflying/FlashSaleProject\nFAQ 怎么防止超卖的 一开始跟着做项目的时候 防止超卖是用的Redis配合Lua脚本预减库存来实现的 后来通过学习和思考 感觉Lua脚本不是必要的 因为Redis提供的incr和decr命令本身就是原子性的 然后又发现靠Redis预减库存来实现也不是最好的方案 因为防止超卖就是防止数据库库存小于零 那就在更新库存的时候加一个判断 库存大于零时才可以成功减库存 就可以实现防止超卖了 这种方式就要求我们系统上游做好限流并消息队列异步下单 使得到数据库的并发量在数据库能接受的范畴内 当然如果数据库压力还是太大 这时候可以采用Redis来保护数据库 在异步下单前用Redis预减库存（当Redis库存已经为0的时候 就没有必要再去尝试更新数据库了） 这样也可以减少数据库压力 但Redis主要是起到辅助作用 防止超卖的实现最终还是靠数据库 -还有其他解决方案 比如服务单机部署的时候可以用synchroinzed和reentrantlock -服务多机部署的时候可以用分布式锁 但我个人感觉是把事情复杂化了 怎么做的限流 项目里主要是 接口限流 统计用户短时间内发送请求的次数 如果超过阈值就拒绝请求（将访问的接口和用户id作为键，访问次数作为值存入到redis中） 验证码限流 将瞬间的请求分散到一个区间内 降低服务器压力 更好的做法 采用令牌桶算法控制请求到达服务器的速度 在消息队列的生产端 可以通过Redis来保证消息的幂等性 最好做到每个用户只发送一个有效请求 多余的请求拦截 限流-令牌桶算法 令牌桶算法：固定大小的令牌桶以恒定的速率生成令牌，当令牌消耗速率小于生成的速率时，令牌就会不断增加，直到把桶填满，拿到令牌的用户才能执行后续的操作，以此来实现限流。 漏桶算法：请求先放到漏桶里，然后以一定的速度放出，当请求流入速度过大时漏桶会直接溢出，溢出的请求就丢弃掉 二者的区别是漏桶算法能强行改变请求流出漏桶的速度，令牌桶在这个基础上还能允许某种程度的突发传输（只要令牌桶中还有令牌，就可以一直来取，直到桶里没有令牌了） 令牌桶: 维护一个令牌桶，该桶以固定的速率添加令牌。桶有一个容量上限，当桶满时，新产生的令牌会被丢弃。 请求处理: 当一个请求到达服务器时，它需要从令牌桶中取出一个令牌才能被处理。如果桶中有足够的令牌，请求被允许通过并且相应数量的令牌被移除；如果桶中没有足够的令牌，请求要么被拒绝，要么被排队等待直到有足够的令牌。 速率控制: 通过调整令牌的添加速率和桶的容量，可以控制请求到达服务器的速度。添加令牌的速率决定了允许的最大请求速率，而桶的容量决定了在短时间内允许的突发请求量。 项目中的技术难点 怎么解决的（防止超卖 限流 缓存数据库一致性） 最主要的就是如何解决超卖的问题一开始跟着做项目的时候 就是用的Redis配合Lua脚本预减库存来实现的 后来通过学习别的资料发现还有其他解决方案 比如服务单机部署的时候可以用synchroinzed和reentrantlock 服务多级部署的时候可以用分布式锁 但我感觉这些都把问题复杂化了，最好的方式还是通过数据库来实现 因为防止超卖就是防止数据库库存小于零 那就在更新库存的时候加一个判断 库存大于零时才可以成功减库存 这种方式就要求我们系统上游做好限流 比如令牌桶 拿到令牌的请求通过消息队列异步下单 如果数据库压力还是太大 可以在异步下单前用Redis预减库存（通过Redis提供的incr decr原子操作） 当Redis库存已经为0的时候 就没有必要再去尝试更新数据库了 这样也可以减少数据库压力 Redis主要是起到辅助作用 限流 其次就是通过Redis来实现消息队列生产端消息幂等性，缓解数据库和缓存不一致的问题，在秒杀场景中缓存和数据库数据不一致的影响不是很大 因为最严重的情况就是数据库中还有库存 而缓存中库存为0了 导致用户无法购买 我感觉出现这种情况最大的可能就是 一个用户发送了多个秒杀请求 预减了多次Redis库存 但是最后只能成功扣减数据库库存一次 可以通过这种方式解决 在用户第一次秒杀请求预减库存之后 将用户ID-商品ID存入一个set中（预减库存和存Set两步放到Lua脚本里保证原子性），在Redis预减库存之前先判断该用户是否已经发送了对该商品的秒杀请求 如果有了就返回请勿重复秒杀 这样一来不一致性能缓解很多 怎么解决的数据库和缓存一致性问题 在秒杀场景中缓存和数据库数据不一致的影响不是很大 因为最严重的情况就是数据库中还有库存（redis预减库存成功，但是mysql减库存失败） 而缓存中库存为0了 导致用户无法购买 我感觉出现这种情况最大的可能就是 一个用户发送了多个秒杀请求 预减了多次Redis库存 但是最后只能成功扣减数据库库存一次 可以通过这种方式解决 在用户第一次秒杀请求预减库存之后 将用户ID-商品ID存入一个set中（预减库存和存Set两步放到Lua脚本里保证原子性），在Redis预减库存之前先判断该用户是否已经发送了对该商品的秒杀请求 如果有了就返回请勿重复秒杀 这样一来不一致性能缓解很多 此外如果秒杀时间很短 那没有必要保持数据库和缓存的一致性 只要保证不超卖 少卖一些产品也没关系 如果秒杀时间比较长或者存在补货行为 可以定期或者在系统并发量小的时候把数据库的库存同步到缓存中 也不需要保证数据强一致 如何设计一个高并发秒杀系统 主要就是针对三个方面 高性能、一致性、高可用 高性能是指能够支持高并发访问 一致性是指在大量并发减库存情况下保证库存的正确性 不能多卖、少卖 高可用是指在复杂的工况下能保证秒杀活动的顺利进行 核心思想就是尽量将请求拦截在系统的上游 尽量采用缓存来保护数据库 同步操作异步化 尽早失败、保护业务系统 比如10万个用户来抢100个资源，其中有99.9%的用户请求都是无效的，那就没有必要让这么多请求到达缓存甚至数据库，徒增系统压力，此时可以通过Redis令牌限流，只允许5000个请求进入业务系统，但是5000个请求并发去操作数据库，数据库可能也会扛不住，所以需要做异步处理，把5000个请求放到消息队列慢慢处理，有效地把并发同步请求变成了串行异步。 优化的方法有限流、削峰、异步、利用缓存、禁止重复请求和重复下单、内存标记、隐藏秒杀接口、 为什么用Redis Redis单线程和高并发不是矛盾吗 这个要看场景 比如秒杀商品只有10个库存 秒杀时候有十万个请求过来 在系统上游进行拦截 只放50或者100个请求进去 其他直接拦截 那么就不需要Redis了 数据库完全可以承受这个程度的并发量 但如果是1000的库存 那至少需要放5000的请求进来 如果这么多请求打到数据库上 会造成比较严重的读写冲突 用户体验不会好 而且如果并发量再大一些的话 数据库可能直接崩掉了 所以这时候就要用缓存和异步处理来保护数据库 Redis确实是单线程的 但是也比并发条件下的数据库读写快太多了（它是面向短快请求的缓存服务(不处理大数据量的请求和复杂事务)、基于内存、数据结构简单）相比较于数据库崩掉的风险 Redis单线程这里损耗的性能不是很关键 还是得先保证秒杀活动能正常进行 从另一个角度来说 既然超过百分之99的请求都是无效请求 那就应该让它们越早失败越好 如果不用Redis做缓存 得到查到数据库库存的时候才让它失败 压力就又来到数据库这边了 高并发场景用乐观锁还是悲观锁 这个还是要看具体的场景 如果系统上游没有做好限流 数据库面临大量的并发读写 这时候用悲观锁 如果用乐观锁会导致大量的请求返回失败 用户体验和系统性能都不好 如果系统的上游做了限流 到数据库的请求不是瞬时大量的话 可以用版本号机制的乐观锁 因为请求不多 就算失败了也很快能重试成功 可以提高系统性能 加锁能解决很多问题 但是一旦加锁就会涉及到锁的竞争 性能就会下降 慢SQL优化 分库分表 先通过慢查询日志来定位慢SQL 它会记录执行时间超过指定时间的SQL 如果查询语句用了* 改成具体字段 如果用了嵌套 改成多表联查 看条件部分有没有用索引 没有索引添加索引 用了索引看是否失效 数据库优化方面 读写分离、主从复制、负载均衡 增加innodb_buffer_pool_size的大小 这样能提高写的速度（能不去硬盘写就不去硬盘写） 秒杀中如何解决重复下单问题？ 缓存方面：用户生成了秒杀订单后，会将用户信息、商品信息作为key，将订单信息作为val，存放到redis中，当同一个用户对同一个商品再次进行下单操作时，会先去redis中查询是否已经存在该秒杀订单 mysql层面，在订单表中建立用户id和商品id的唯一索引 分布式会话问题(如何判断用户有没有登录)？ 用户登录后，服务端会生成一个UUID交给客户端存入cookie中，之后客户端只需要携带这个cookie来请求数据即可 同时服务器端会把UUID和用户信息作为键值对存入到redis中，并设置一个过期时间，后续要判断是否登录过时，去redis中获取对应的用户信息就行，能获取到说明已经登录了，如果没有获取到就跳转到登录页面。因为用户信息是缓存在Redis中的，访问多台服务器也不会出现需要登录多次或者登录无效的问题。 用户秒杀流程（登录-输入验证码-立即秒杀-创建真实秒杀地址-判断是否重复抢购-预减库存-创建消息（已在排队）-消费者消费消息-判断是否重复抢购-更新库存、生成订单并放到redis中-用户进入排队状态后轮询查看是否抢购成功） 首先用户在客户端键入用户名和密码，然后前端会使用盐和md5对用户输入的密码进行一次加密，然后将用户名和加密后的密码传输到服务器端 服务端首先会用正则表达式验证用户名的合法性（手机号是否合法），然后根据手机号去数据库获取用户信息，若为空说明未注册 然后服务器会对前端发来的密码二次加密，和数据库中取出来的密码进行比对，如果不一致，说明密码错误（密码在存入数据库前还会进行一次加密） 比对成功，则登陆成功，同时通过uuid生成一个token放入到cookie中返回给客户端，还将token作为key，用户信息作为val存入redis，解决分布式session问题 登陆成功后，会跳转到商品列表页面，同时会将商品列表页存入到redis中（存放的为String）过期时间60s 点击商品详情后，会判断秒杀是否开始以及结束，同时返回商品的详情信息，在没有开始秒杀之前不能购买，秒杀时间是以服务器的时间为准，客户端读取一次服务器当前的时间，然后每过一秒将剩余时间减1 可以秒杀后，用户先点击刷新验证码，这时会生成验证码并将正确答案存入Redis中，然后用户在表单中填写验证码 用户点击了立即秒杀之后 首先在拦截器里 判断用户登录状态（从cookie中获取token 在Redis中查是否存在以这个token为键的用户）如果登录过 将用户存放在ThreadLocals这个map里 Controller层的方法使用User时可以直接从TreadLocals中获取 不用再写通过cookie Redis获取user的逻辑 访问接口结束后 手动Remove TreadLocal变量 防止内存泄漏 接口限流 统计用户短时间内发送请求的次数 如果超过阈值就拒绝请求 进行验证码校验（将前端传过来的验证码结果与Redis中存储的验证码进行比对 一致就通过） 创建真实的秒杀地址（UUID加盐再用MD5加密）将秒杀地址存到Redis中 然后到达秒杀接口、判断用户登录状态-验证秒杀地址(前端传过来的和存在Redis中的是否一致)-判断是否重复抢购（Redis中是否有该用户-商品的键值对）- 是否有内存标记（某商品Redis库存为0后 就将该商品ID存入一个Map中（商品id-true） 减少对Redis的访问 项目启动时 除了商品库存放到Redis里 还把商品-false存到Map里）- 通过lua脚本预减Redis库存 - 然后创建一个消息发送到消息队 …","date":1714521600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1714521600,"objectID":"0dc98d853ae2b374e154a6fb1c292534","permalink":"https://hyflying.github.io/post/e-commerce-flash-sales/","publishdate":"2024-05-01T00:00:00Z","relpermalink":"/post/e-commerce-flash-sales/","section":"post","summary":"The Flash Sale Project is a high-performance system designed for managing flash sales, implemented in Java. It features real-time inventory management, user authentication, and efficient order processing. The project utilizes Spring Boot for the backend, MySQL for the database, Redis for caching, and RabbitMQ for message queuing.","tags":null,"title":"E-commerce flash sales FAQ","type":"post"},{"authors":null,"categories":null,"content":"Project2 Extendible Hash 算法简述 两个重要概念\ndirectory：目录页，根据取最低的global depth位bits，得到key对应的bucket bucket：存hashed key 三个重要变量：\nglobal depth：规定看最低多少位bits，global depth为n，有2^n个directories local depth：bucket的depth，规定bucket只看最低local depth位的bits来分配hashed key放到哪个bucket中，local depth不能大于global depth bucket size：规定了一个bucket里最多放多少个hashed key insert一个key 讨论最常见的三种情况。\nbucket没有满 这种情况下直接插入就行\nbucket满了，但是bucket的local depth还是小于global depth 此时需要split bucket，并将local depth+1，更新directory指向local depth的指针，同时根据新的local depth重新分配被分裂桶中的元素以及新加的元素\nbucket满了，并且bucket的local depth等于global depth 因为local depth不能大于global depth，因此这种情况下，需要global depth先加1，global depth加1之后，directories要✖️2，就是复制一份原来的directories，bucket的local depth也要加1，然后split bucket，directory指向分裂的buckets的指针要重新分配，分裂的buckets里的hashed key也要重新分配。\n项目代码简述 ExtendibleHTableDirectoryPage 成员变量 uint32_t max_depth_; uint32_t global_depth_; uint8_t local_depths_[HTABLE_DIRECTORY_ARRAY_SIZE]; //local depth数组 page_id_t bucket_page_ids_[HTABLE_DIRECTORY_ARRAY_SIZE];//指向对应的bucket 函数 这里的bucket_idx是根据key以及global depth hash得来的，指向具体的bucket\nauto ExtendibleHTableDirectoryPage::GetSplitImageIndex(uint32_t bucket_idx) const -\u0026gt; uint32_t { //GetSplitImageIndex要在local depth + 1之后。 uint32_t local_depth = local_depths_[bucket_idx]; return bucket_idx^(1U \u0026lt;\u0026lt; (local_depth - 1)); } ExtendibleHTableBucketPage 这里的bucket_idx是指向当前桶里的某个元素的idx，桶里元素是key，value的pair\nExtendibleHTableHeaderPage 创建一个headerPage，不能用构造函数。要从bpm中拿到新的一个page\npage_id_t header_page_id = INVALID_PAGE_ID; BasicPageGuard header_guard = bpm_-\u0026gt;NewPageGuarded(\u0026amp;header_page_id); header_page_ = header_guard.AsMut\u0026lt;ExtendibleHTableHeaderPage\u0026gt;(); header_page_-\u0026gt;Init(header_max_depth_); PageGuard auto BasicPageGuard::UpgradeWrite() -\u0026gt; WritePageGuard auto BasicPageGuard::UpgradeRead() -\u0026gt; ReadPageGuard page先加对应的锁，然后再生成Read/WritePageGuard,原先的bpm_和page_置空\nBug记录 BufferPoolManager的pool size很小的时候，如果fetch完页面，用完之后不及时释放锁，可能会导致pool里所有页面都是锁着的，而此时如果再fetch新页面，会有问题。因此用完页面以后要及时释放 GetValue的时候，可能访问的directory_page或者bucket_page都不存在，那这种情况下返回的page_id会是IN_VALID_PAGE_ID,需要直接返回false ","date":1709251200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1709251200,"objectID":"086fe3e24c02067616ee39b3031a7594","permalink":"https://hyflying.github.io/post/cmu15445-p2/","publishdate":"2024-03-01T00:00:00Z","relpermalink":"/post/cmu15445-p2/","section":"post","summary":"CMU15445's Project2 implements an Extendible Hash for dynamic data indexing. It manages keys with global and local depths and handles variable scenarios during insertion. Identified bugs pertain to BufferPoolManager capacity and invalid page handling.","tags":null,"title":"Extendible Hash","type":"post"},{"authors":null,"categories":null,"content":"Project1 BufferPoolManager LRU-K LRU-K算法是干什么的？它是一个页面置换算法，系统将虚拟内存地址划分为各个虚拟页(page_id),将物理内存地址划分为物理页(frame_id)，当物理内存满了以后，就得决定该淘汰哪个虚拟页，从而能够加载新的虚拟页。\n成员变量 LRUKReplacer成员变量\nstd::unordered_map\u0026lt;frame_id_t, LRUKNode\u0026gt; node_store_; frame_id具体存的LRUKNode\nsize_t current_timestamp_{0}; 当前的时间戳，用每加入一个新页面自增来模拟\nsize_t curr_size_{0}; 当前可淘汰的(evictable)页面数量\nsize_t replacer_size_; max size of frame\nsize_t k_;\nstd::mutex latch_;\nLRUKNode成员变量\nframe_id_t fid_;\nstd::list\u0026lt;size_t\u0026gt; history_;\nsize_t k_;\nbool is_evictable_{false}; 标记页面是否可以被淘汰\n函数 LRUKNode函数\nauto GetKDistance(size_t cur) -\u0026gt; uint64_t 计算时间差，如果该页面的历史次数小于k次，则为正无穷，如果大于等于k次，则计算当前时间戳与第k次的时间差，并返回。\nLRUKReplacer函数\nauto Evict(frame_id_t *frame_id) -\u0026gt; bool; 淘汰可淘汰的页面中(is_evictabe = true)，时间距离最远的page\nvoid RecordAccess(frame_id_t frame_id, AccessType access_type = AccessType::*Unknown*); 记录访问了哪个frame页面。考虑节点是否已经存在，如果不存在且replacer的size已经满的情况下访问失败，否则如果存在history_list加入当前时间戳，然后current_timestamp自增；如果不存在先建立新的LRUKNode节点，再做后续的步骤\nvoid LRUKReplacer::SetEvictable(frame_id_t frame_id, bool set_evictable) 该函数会影响curr_size的大小，因为curr_size返回的是当前可淘汰页面的数量，如果通过该函数把以前false的设置为true了，那curr_size要自增，反之则自减\nvoid LRUKReplacer::Remove(frame_id_t frame_id) 驱逐某个页面。首先要保证该页面是否存在，如果存在还要保证该页面是否可以被驱逐，在前两个条件都满足的情况下，可以驱逐这个页面，curr_size要减1。\nBufferPoolManager 成员变量 BufferPoolManager成员变量\nconst size_t pool_size_; bufferpool的size，代表了可以有多少页面在bufferpool里\nstd::atomic\u0026lt;page_id_t\u0026gt; next_page_id_ = 0; 下一个page_id，从0开始保持自增\nPage *pages_; 一个数组，存放的是bufferpool中的页面，根据frame_id得到当前frame保存的page\nstd::unique_ptr\u0026lt;DiskScheduler\u0026gt; disk_scheduler_ __attribute__((__unused__)); 负责向磁盘读写页面内容\nstd::unordered_map\u0026lt;page_id_t, frame_id_t\u0026gt; page_table_; 记录虚拟页面对应的物理内存页面\nstd::unique_ptr\u0026lt;LRUKReplacer\u0026gt; replacer_;\nstd::list\u0026lt;frame_id_t\u0026gt; free_list_; 空闲的物理页面，如果有就不需要考虑替换哪个页面了\nstd::mutex latch_; latch 是一种轻量级的同步机制，用于保护短期操作，而 lock 是一种用于控制长期访问共享资源的同步机制，通常用于实现事务的隔离和一致性。\nDiskScheduler\nDiskManager *disk_manager_ __attribute__((__unused__));\nChannel\u0026lt;std::optional\u0026lt;DiskRequest\u0026gt;\u0026gt; request_queue_; 处理请求队列\nstd::optional\u0026lt;std::thread\u0026gt; background_thread_; 在后台线程处理请求\nstruct DiskRequest { /** Flag indicating whether the request is a write or a read. */ bool is_write_; /** * Pointer to the start of the memory location where a page is either: * 1. being read into from disk (on a read). * 2. being written out to disk (on a write). */ char *data_; /** ID of the page being read from / written to disk. */ page_id_t page_id_; /** Callback used to signal to the request issuer when the request has been completed. */ std::promise\u0026lt;bool\u0026gt; callback_; }; 函数 BufferPoolManager\n构造函数 构造函数需要做三件事，首先初始化replacer，第二根据pool_size初始化pages数组，最后把所有页面都放入free_list中。\nauto NewPage(page_id_t *page_id) -\u0026gt; Page *; 新生成一个虚拟页面，虚拟页面得有对应的物理页面。所以需要判断free_list有无可用的物理页面，如果有就直接取空闲页面，如果没有得调用replacer根据LRUK驱逐一个页面。如果驱逐出去的页面是dirty的，那我们得把这个页面写回给磁盘。然后要将新页面的pin_count设置为1，调用\nreplacer_-\u0026gt;RecordAccess(frame_id);和replacer_-\u0026gt;SetEvictable(frame_id, false);两个函数，因为生成了新页面以后肯定是要用的，所以要调用这两个函数。\nauto NewPageGuarded(page_id_t *page_id) -\u0026gt; BasicPageGuard; 该函数在project2中完成，用于管理pin_count，不需要手动unpin\nauto FetchPage(page_id_t page_id, AccessType access_type = AccessType::*Unknown*) -\u0026gt; Page *; 如果缓冲池中有该page，可以直接取到page，pin_count加1，调用\nreplacer_-\u0026gt;RecordAccess(frame_id);replacer_-\u0026gt;SetEvictable(frame_id, false);然后返回该page。\n如果不存在，先确定page加载到哪个frame页面，然后从磁盘读取该page数据，加载到frame中。这一步其实与NewPage逻辑有点相似，只不过NewPage只要返回空的page就可以，但是fetchPage得返回从磁盘中读取的page\nauto UnpinPage(page_id_t page_id, bool is_dirty, AccessType access_type = AccessType::*Unknown*) -\u0026gt; bool; 通过is_dirty参数告诉bpm该页面是否被修改过，然后需要对引用次数减1。如果引用次数为0，那么调用replacer_-\u0026gt;SetEvictable(frame_id, true);说明该页面已经被用完了，可以被驱逐了。\nauto FlushPage(page_id_t page_id) -\u0026gt; bool; 通过DiskScheduler将脏页面写回磁盘\nauto promise = disk_scheduler_-\u0026gt;CreatePromise(); auto future = promise.get_future(); disk_scheduler_-\u0026gt;Schedule({true, page-\u0026gt;GetData(), page-\u0026gt;GetPageId(), std::move(promise)}); future.get(); ","date":1707091200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1707091200,"objectID":"1d169f7641b670cd965f1419adeb29da","permalink":"https://hyflying.github.io/post/cmu15445-p1/","publishdate":"2024-02-05T00:00:00Z","relpermalink":"/post/cmu15445-p1/","section":"post","summary":"In the CMU15445 project, the BufferPoolManager utilizes the LRU-K algorithm for memory management, handling virtual and physical page allocations within a buffer pool. Key functions include page creation, eviction based on access history, and writing 'dirty' pages back to disk, thereby optimizing database performance and memory use.","tags":null,"title":"BufferPoolManager","type":"post"},{"authors":["黄燕飞"],"categories":null,"content":" Create your slides in Markdown - click the Slides button to check out the example. Add the publication’s full text or supplementary notes here. You can use rich formatting such as including code, math, and images.\n","date":1554595200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1554595200,"objectID":"557dc08fd4b672a0c08e0a8cf0c9ff7d","permalink":"https://hyflying.github.io/publication/preprint/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/preprint/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example preprint / working paper","type":"publication"},{"authors":[],"categories":[],"content":"Create slides in Markdown with Hugo Blox Builder Hugo Blox Builder | Documentation\nFeatures Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides Controls Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click PDF Export Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026#34;blueberry\u0026#34; if porridge == \u0026#34;blueberry\u0026#34;: print(\u0026#34;Eating...\u0026#34;) Math In-line math: $x + y = z$\nBlock math:\n$$ f\\left( x \\right) = ;\\frac{{2\\left( {x + 4} \\right)\\left( {x - 4} \\right)}}{{\\left( {x + 4} \\right)\\left( {x + 1} \\right)}} $$\nFragments Make content appear incrementally\n{{% fragment %}} One {{% /fragment %}} {{% fragment %}} **Two** {{% /fragment %}} {{% fragment %}} Three {{% /fragment %}} Press Space to play!\nOne Two Three A fragment can accept two optional parameters:\nclass: use a custom style (requires definition in custom CSS) weight: sets the order in which a fragment appears Speaker Notes Add speaker notes to your presentation\n{{% speaker_note %}} - Only the speaker can read these notes - Press `S` key to view {{% /speaker_note %}} Press the S key to view the speaker notes!\nOnly the speaker can read these notes Press S key to view Themes black: Black background, white text, blue links (default) white: White background, black text, blue links league: Gray background, white text, blue links beige: Beige background, dark text, brown links sky: Blue background, thin dark text, blue links night: Black background, thick white text, orange links serif: Cappuccino background, gray text, brown links simple: White background, black text, blue links solarized: Cream-colored background, dark green text, blue links Custom Slide Customize the slide style and background\n{{\u0026lt; slide background-image=\u0026#34;/media/boards.jpg\u0026#34; \u0026gt;}} {{\u0026lt; slide background-color=\u0026#34;#0000FF\u0026#34; \u0026gt;}} {{\u0026lt; slide class=\u0026#34;my-style\u0026#34; \u0026gt;}} Custom CSS Example Let’s make headers navy colored.\nCreate assets/css/reveal_custom.css with:\n.reveal section h1, .reveal section h2, .reveal section h3 { color: navy; } Questions? Ask\nDocumentation\n","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1549324800,"objectID":"0e6de1a61aa83269ff13324f3167c1a9","permalink":"https://hyflying.github.io/slides/example/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"/slides/example/","section":"slides","summary":"An introduction to using Hugo Blox Builder's Slides feature.","tags":[],"title":"Slides","type":"slides"},{"authors":null,"categories":null,"content":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.\nNullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.\nCras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.\nSuspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.\nAliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.\n","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"e8f8d235e8e7f2efd912bfe865363fc3","permalink":"https://hyflying.github.io/project/example/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/project/example/","section":"project","summary":"An example of using the in-built project page.","tags":["Deep Learning"],"title":"Example Project","type":"project"},{"authors":null,"categories":null,"content":"","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"d1311ddf745551c9e117aa4bb7e28516","permalink":"https://hyflying.github.io/project/external-project/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/project/external-project/","section":"project","summary":"An example of linking directly to an external project website using `external_link`.","tags":["Demo"],"title":"External Project","type":"project"},{"authors":["黄燕飞","Robert Ford"],"categories":null,"content":" Click the Cite button above to demo the feature to enable visitors to import publication metadata into their reference management software. Create your slides in Markdown - click the Slides button to check out the example. Add the publication’s full text or supplementary notes here. You can use rich formatting such as including code, math, and images.\n","date":1441065600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1441065600,"objectID":"966884cc0d8ac9e31fab966c4534e973","permalink":"https://hyflying.github.io/publication/journal-article/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/journal-article/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example journal article","type":"publication"},{"authors":["黄燕飞","Robert Ford"],"categories":null,"content":" Click the Cite button above to demo the feature to enable visitors to import publication metadata into their reference management software. Create your slides in Markdown - click the Slides button to check out the example. Add the publication’s full text or supplementary notes here. You can use rich formatting such as including code, math, and images.\n","date":1372636800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1372636800,"objectID":"69425fb10d4db090cfbd46854715582c","permalink":"https://hyflying.github.io/publication/conference-paper/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/conference-paper/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":[],"title":"An example conference paper","type":"publication"}]